[
  {
    "raw_dockerfile": "# syntax = docker/dockerfile-upstream:1.1.2-experimental\n\n# Meta args applied to stage base names.\n\nARG TOOLS\nARG GO_VERSION\n\n# The tools target provides base toolchain for the build.\n\nFROM $TOOLS AS tools\nENV PATH /toolchain/bin:/toolchain/go/bin\nRUN [\"/toolchain/bin/mkdir\", \"/bin\", \"/tmp\"]\nRUN [\"/toolchain/bin/ln\", \"-svf\", \"/toolchain/bin/bash\", \"/bin/sh\"]\nRUN [\"/toolchain/bin/ln\", \"-svf\", \"/toolchain/etc/ssl\", \"/etc/ssl\"]\nRUN curl -sfL https://install.goreleaser.com/github.com/golangci/golangci-lint.sh | bash -s -- -b /toolchain/bin v1.24.0\nRUN cd $(mktemp -d) \\\n    && go mod init tmp \\\n    && go get mvdan.cc/gofumpt/gofumports@aaa7156f4122b1055c466e26e77812fa32bac1d9 \\\n    && mv /go/bin/gofumports /toolchain/go/bin/gofumports\nRUN curl -sfL https://github.com/uber/prototool/releases/download/v1.8.0/prototool-Linux-x86_64.tar.gz | tar -xz --strip-components=2 -C /toolchain/bin prototool/bin/prototool\nCOPY ./hack/docgen /go/src/github.com/talos-systems/docgen\nRUN cd /go/src/github.com/talos-systems/docgen \\\n    && go build . \\\n    && mv docgen /toolchain/go/bin/\n\n# The build target creates a container that will be used to build Talos source\n# code.\n\nFROM scratch AS build\nCOPY --from=tools / /\nSHELL [\"/toolchain/bin/bash\", \"-c\"]\nENV PATH /toolchain/bin:/toolchain/go/bin\nENV GO111MODULE on\nENV GOPROXY https://proxy.golang.org\nENV CGO_ENABLED 0\nWORKDIR /src\n\n# The generate target generates code from protobuf service definitions.\n\nFROM build AS generate-build\n# Common needs to be at or near the top to satisfy the subsequent imports\nCOPY ./api/common/common.proto /api/common/common.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api common/common.proto\nCOPY ./api/health/health.proto /api/health/health.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api health/health.proto\nCOPY ./api/os/os.proto /api/os/os.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api os/os.proto\nCOPY ./api/security/security.proto /api/security/security.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api security/security.proto\nCOPY ./api/machine/machine.proto /api/machine/machine.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api machine/machine.proto\nCOPY ./api/time/time.proto /api/time/time.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api time/time.proto\nCOPY ./api/network/network.proto /api/network/network.proto\nRUN protoc -I/api --go_out=plugins=grpc,paths=source_relative:/api network/network.proto\n# Gofumports generated files to adjust import order\nRUN gofumports -w -local github.com/talos-systems/talos /api/\n\nFROM scratch AS generate\nCOPY --from=generate-build /api/common/common.pb.go /api/common/\nCOPY --from=generate-build /api/health/health.pb.go /api/health/\nCOPY --from=generate-build /api/os/os.pb.go /api/os/\nCOPY --from=generate-build /api/security/security.pb.go /api/security/\nCOPY --from=generate-build /api/machine/machine.pb.go /api/machine/\nCOPY --from=generate-build /api/time/time.pb.go /api/time/\nCOPY --from=generate-build /api/network/network.pb.go /api/network/\n\n# The base target provides a container that can be used to build all Talos\n# assets.\n\nFROM build AS base\nCOPY ./go.mod ./\nCOPY ./go.sum ./\nRUN go mod download\nRUN go mod verify\nCOPY ./cmd ./cmd\nCOPY ./pkg ./pkg\nCOPY ./internal ./internal\nCOPY --from=generate /api ./api\nRUN go list -mod=readonly all >/dev/null\nRUN ! go mod tidy -v 2>&1 | grep .\n\n# The init target builds the init binary.\n\nFROM base AS init-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/internal/app/init\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Talos -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /init\nRUN chmod +x /init\n\nFROM scratch AS init\nCOPY --from=init-build /init /init\n\n# The machined target builds the machined image.\n\nFROM base AS machined-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/internal/app/machined\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Talos -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /machined\nRUN chmod +x /machined\n\nFROM scratch AS machined\nCOPY --from=machined-build /machined /machined\n\n# The timed target builds the timed image.\n\nFROM base AS timed-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/internal/app/timed\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /timed\nRUN chmod +x /timed\n\nFROM base AS timed-image\nARG TAG\nARG USERNAME\nCOPY --from=timed-build /timed /scratch/timed\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./timed /timed\\nENTRYPOINT [\\\"/timed\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/timed:${TAG} --output type=docker,dest=/timed.tar --no-console  .\n\n# The apid target builds the api image.\n\nFROM base AS apid-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/internal/app/apid\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /apid\nRUN chmod +x /apid\n\nFROM base AS apid-image\nARG TAG\nARG USERNAME\nCOPY --from=apid-build /apid /scratch/apid\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./apid /apid\\nENTRYPOINT [\\\"/apid\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/apid:${TAG} --output type=docker,dest=/apid.tar --no-console  .\n\n# The osd target builds the osd image.\n\nFROM base AS osd-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/internal/app/osd\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /osd\nRUN chmod +x /osd\n\nFROM base AS osd-image\nARG TAG\nARG USERNAME\nCOPY --from=osd-build /osd /scratch/osd\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./osd /osd\\nENTRYPOINT [\\\"/osd\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/osd:${TAG} --output type=docker,dest=/osd.tar --no-console  .\n\n# The trustd target builds the trustd image.\n\nFROM base AS trustd-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/internal/app/trustd\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /trustd\nRUN chmod +x /trustd\n\nFROM base AS trustd-image\nARG TAG\nARG USERNAME\nCOPY --from=trustd-build /trustd /scratch/trustd\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./trustd /trustd\\nENTRYPOINT [\\\"/trustd\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/trustd:${TAG} --output type=docker,dest=/trustd.tar --no-console  .\n\n# The networkd target builds the networkd image.\n\nFROM base AS networkd-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/internal/pkg/version\"\nWORKDIR /src/internal/app/networkd\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /networkd\nRUN chmod +x /networkd\n\nFROM base AS networkd-image\nARG TAG\nARG USERNAME\nCOPY --from=networkd-build /networkd /scratch/networkd\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./networkd /networkd\\nENTRYPOINT [\\\"/networkd\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/networkd:${TAG} --output type=docker,dest=/networkd.tar --no-console  .\n\n# The routerd target builds the routerd image.\n\nFROM base AS routerd-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/internal/pkg/version\"\nWORKDIR /src/internal/app/routerd\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /routerd\nRUN chmod +x /routerd\n\nFROM base AS routerd-image\nARG TAG\nARG USERNAME\nCOPY --from=routerd-build /routerd /scratch/routerd\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./routerd /routerd\\nENTRYPOINT [\\\"/routerd\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/routerd:${TAG} --output type=docker,dest=/routerd.tar --no-console  .\n\n\n# The bootkube target builds the bootkube image.\n\nFROM base AS bootkube-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/internal/pkg/version\"\nWORKDIR /src/internal/app/bootkube\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Server -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /bootkube\nRUN chmod +x /bootkube\n\nFROM base AS bootkube-image\nARG TAG\nARG USERNAME\nCOPY --from=bootkube-build /bootkube /scratch/bootkube\nWORKDIR /scratch\nRUN printf \"FROM scratch\\nCOPY ./bootkube /bootkube\\nENTRYPOINT [\\\"/bootkube\\\"]\" > Dockerfile\nRUN --security=insecure img build --tag ${USERNAME}/bootkube:${TAG} --output type=docker,dest=/bootkube.tar --no-console  .\n\n\n# The talosctl targets build the talosctl binaries.\n\nFROM base AS talosctl-linux-amd64-build\nARG SHA\nARG TAG\nARG ARTIFACTS\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nARG MGMT_HELPERS_PKG=\"github.com/talos-systems/talos/cmd/talosctl/pkg/mgmt/helpers\"\nWORKDIR /src/cmd/talosctl\nRUN --mount=type=cache,target=/.cache/go-build GOOS=linux GOARCH=amd64 go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG} -X ${MGMT_HELPERS_PKG}.ArtifactsPath=${ARTIFACTS}\" -o /talosctl-linux-amd64\nRUN chmod +x /talosctl-linux-amd64\n\nFROM base AS talosctl-linux-arm64-build\nARG SHA\nARG TAG\nARG ARTIFACTS\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nARG MGMT_HELPERS_PKG=\"github.com/talos-systems/talos/cmd/talosctl/pkg/mgmt/helpers\"\nWORKDIR /src/cmd/talosctl\nRUN --mount=type=cache,target=/.cache/go-build GOOS=linux GOARCH=arm64 go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG} -X ${MGMT_HELPERS_PKG}.ArtifactsPath=${ARTIFACTS}\" -o /talosctl-linux-arm64\nRUN chmod +x /talosctl-linux-arm64\n\nFROM base AS talosctl-linux-armv7-build\nARG SHA\nARG TAG\nARG ARTIFACTS\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nARG MGMT_HELPERS_PKG=\"github.com/talos-systems/talos/cmd/talosctl/pkg/mgmt/helpers\"\nWORKDIR /src/cmd/talosctl\nRUN --mount=type=cache,target=/.cache/go-build GOOS=linux GOARCH=arm GOARM=7  go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG} -X ${MGMT_HELPERS_PKG}.ArtifactsPath=${ARTIFACTS}\" -o /talosctl-linux-armv7\nRUN chmod +x /talosctl-linux-armv7\n\nFROM scratch AS talosctl-linux\nCOPY --from=talosctl-linux-amd64-build /talosctl-linux-amd64 /talosctl-linux-amd64\nCOPY --from=talosctl-linux-arm64-build /talosctl-linux-arm64 /talosctl-linux-arm64\nCOPY --from=talosctl-linux-armv7-build /talosctl-linux-armv7 /talosctl-linux-armv7\n\nFROM base AS talosctl-darwin-build\nARG SHA\nARG TAG\nARG ARTIFACTS\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nARG MGMT_HELPERS_PKG=\"github.com/talos-systems/talos/cmd/talosctl/pkg/mgmt/helpers\"\nWORKDIR /src/cmd/talosctl\nRUN --mount=type=cache,target=/.cache/go-build GOOS=darwin GOARCH=amd64 go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG} -X ${MGMT_HELPERS_PKG}.ArtifactsPath=${ARTIFACTS}\" -o /talosctl-darwin-amd64\nRUN chmod +x /talosctl-darwin-amd64\n\nFROM scratch AS talosctl-darwin\nCOPY --from=talosctl-darwin-build /talosctl-darwin-amd64 /talosctl-darwin-amd64\n\n# The kernel target is the linux kernel.\n\nFROM scratch AS kernel\nCOPY --from=docker.io/autonomy/kernel:v0.2.0 /boot/vmlinuz /vmlinuz\nCOPY --from=docker.io/autonomy/kernel:v0.2.0 /boot/vmlinux /vmlinux\n\n# The rootfs target provides the Talos rootfs.\n\nFROM build AS rootfs-base\nCOPY --from=docker.io/autonomy/fhs:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/ca-certificates:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/containerd:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/dosfstools:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/eudev:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/iptables:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/libressl:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/libseccomp:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/linux-firmware:v0.2.0 /lib/firmware/bnx2 /rootfs/lib/firmware/bnx2\nCOPY --from=docker.io/autonomy/linux-firmware:v0.2.0 /lib/firmware/bnx2x /rootfs/lib/firmware/bnx2x\nCOPY --from=docker.io/autonomy/musl:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/runc:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/socat:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/syslinux:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/xfsprogs:v0.2.0 / /rootfs\nCOPY --from=docker.io/autonomy/util-linux:v0.2.0 /lib/libblkid.* /rootfs/lib\nCOPY --from=docker.io/autonomy/util-linux:v0.2.0 /lib/libuuid.* /rootfs/lib\nCOPY --from=docker.io/autonomy/kmod:v0.2.0 /usr/lib/libkmod.* /rootfs/lib\nCOPY --from=docker.io/autonomy/kernel:v0.2.0 /lib/modules /rootfs/lib/modules\nCOPY --from=machined /machined /rootfs/sbin/init\nCOPY --from=apid-image /apid.tar /rootfs/usr/images/\nCOPY --from=bootkube-image /bootkube.tar /rootfs/usr/images/\nCOPY --from=timed-image /timed.tar /rootfs/usr/images/\nCOPY --from=osd-image /osd.tar /rootfs/usr/images/\nCOPY --from=trustd-image /trustd.tar /rootfs/usr/images/\nCOPY --from=networkd-image /networkd.tar /rootfs/usr/images/\nCOPY --from=routerd-image /routerd.tar /rootfs/usr/images/\n# NB: We run the cleanup step before creating extra directories, files, and\n# symlinks to avoid accidentally cleaning them up.\nCOPY ./hack/cleanup.sh /toolchain/bin/cleanup.sh\nRUN cleanup.sh /rootfs\nCOPY hack/containerd.toml /rootfs/etc/cri/containerd.toml\nRUN touch /rootfs/etc/resolv.conf\nRUN touch /rootfs/etc/hosts\nRUN touch /rootfs/etc/os-release\nRUN mkdir -pv /rootfs/{boot,usr/local/share,mnt}\nRUN mkdir -pv /rootfs/{etc/kubernetes/manifests,etc/cni,usr/libexec/kubernetes}\nRUN ln -s /etc/ssl /rootfs/etc/pki\nRUN ln -s /etc/ssl /rootfs/usr/share/ca-certificates\nRUN ln -s /etc/ssl /rootfs/usr/local/share/ca-certificates\nRUN ln -s /etc/ssl /rootfs/etc/ca-certificates\n\nFROM rootfs-base AS rootfs-squashfs\nCOPY --from=rootfs / /rootfs\nRUN mksquashfs /rootfs /rootfs.sqsh -all-root -noappend -comp xz -Xdict-size 100% -no-progress\n\nFROM scratch AS squashfs\nCOPY --from=rootfs-squashfs /rootfs.sqsh /\n\nFROM scratch AS rootfs\nCOPY --from=rootfs-base /rootfs /\n\n# The initramfs target provides the Talos initramfs image.\n\nFROM build AS initramfs-archive\nWORKDIR /initramfs\nCOPY --from=squashfs /rootfs.sqsh .\nCOPY --from=init /init .\nRUN set -o pipefail && find . 2>/dev/null | cpio -H newc -o | xz -v -C crc32 -0 -e -T 0 -z >/initramfs.xz\n\nFROM scratch AS initramfs\nCOPY --from=initramfs-archive /initramfs.xz /initramfs.xz\n\n# The talos target generates a docker image that can be used to run Talos\n# in containers.\n\nFROM scratch AS talos\nCOPY --from=rootfs / /\nENTRYPOINT [\"/sbin/init\"]\n\n# The installer target generates an image that can be used to install Talos to\n# various environments.\n\nFROM base AS installer-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nWORKDIR /src/cmd/installer\nRUN --mount=type=cache,target=/.cache/go-build go build -ldflags \"-s -w -X ${VERSION_PKG}.Name=Talos -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" -o /installer\nRUN chmod +x /installer\n\nFROM alpine:3.8 AS installer\nRUN apk add --no-cache --update \\\n    bash \\\n    ca-certificates \\\n    cdrkit \\\n    qemu-img \\\n    syslinux \\\n    util-linux \\\n    xfsprogs\nCOPY --from=kernel /vmlinuz /usr/install/vmlinuz\nCOPY --from=rootfs /usr/lib/syslinux/ /usr/lib/syslinux\nCOPY --from=initramfs /initramfs.xz /usr/install/initramfs.xz\nCOPY --from=installer-build /installer /bin/installer\nRUN ln -s /bin/installer /bin/talosctl\nARG TAG\nENV VERSION ${TAG}\nLABEL \"alpha.talos.dev/version\"=\"${VERSION}\"\nENTRYPOINT [\"/bin/installer\"]\nONBUILD RUN apk add --no-cache --update \\\n    cpio \\\n    squashfs-tools \\\n    xz\nONBUILD WORKDIR /initramfs\nONBUILD ARG RM\nONBUILD RUN xz -d /usr/install/initramfs.xz \\\n    && cpio -idvm < /usr/install/initramfs \\\n    && unsquashfs -f -d /rootfs rootfs.sqsh \\\n    && for f in ${RM}; do rm -rfv /rootfs$f; done \\\n    && rm /usr/install/initramfs \\\n    && rm rootfs.sqsh\nONBUILD COPY --from=customization / /rootfs\nONBUILD RUN find /rootfs \\\n    && mksquashfs /rootfs rootfs.sqsh -all-root -noappend -comp xz -Xdict-size 100% -no-progress \\\n    && set -o pipefail && find . 2>/dev/null | cpio -H newc -o | xz -v -C crc32 -0 -e -T 0 -z >/usr/install/initramfs.xz \\\n    && rm -rf /rootfs \\\n    && rm -rf /initramfs\nONBUILD WORKDIR /\n\n# The test target performs tests on the source code.\n\nFROM base AS unit-tests-runner\nRUN unlink /etc/ssl\nCOPY --from=rootfs / /\nCOPY hack/golang/test.sh /bin\nARG TESTPKGS\nRUN --security=insecure --mount=type=cache,id=testspace,target=/tmp --mount=type=cache,target=/.cache/go-build /bin/test.sh ${TESTPKGS}\nFROM scratch AS unit-tests\nCOPY --from=unit-tests-runner /src/coverage.txt /coverage.txt\n\n# The unit-tests-race target performs tests with race detector.\n\nFROM golang:${GO_VERSION} AS unit-tests-race\nCOPY --from=base /src /src\nCOPY --from=base /go/pkg/mod /go/pkg/mod\nWORKDIR /src\nENV GO111MODULE on\nARG TESTPKGS\nRUN --mount=type=cache,target=/root/.cache/go-build go test -v -count 1 -race ${TESTPKGS}\n\n# The integration-test target builds integration test binary.\n\nFROM base AS integration-test-linux-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nRUN --mount=type=cache,target=/.cache/go-build GOOS=linux GOARCH=amd64 go test -c \\\n    -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" \\\n    -tags integration,integration_api,integration_cli,integration_k8s \\\n    ./internal/integration\n\nFROM scratch AS integration-test-linux\nCOPY --from=integration-test-linux-build /src/integration.test /integration-test-linux-amd64\n\nFROM base AS integration-test-darwin-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nRUN --mount=type=cache,target=/.cache/go-build GOOS=darwin GOARCH=amd64 go test -c \\\n    -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG}\" \\\n    -tags integration,integration_api,integration_cli,integration_k8s \\\n    ./internal/integration\n\nFROM scratch AS integration-test-darwin\nCOPY --from=integration-test-darwin-build /src/integration.test /integration-test-darwin-amd64\n\n# The integration-test-provision target builds integration test binary with provisioning tests.\n\nFROM base AS integration-test-provision-linux-build\nARG SHA\nARG TAG\nARG VERSION_PKG=\"github.com/talos-systems/talos/pkg/version\"\nARG MGMT_HELPERS_PKG=\"github.com/talos-systems/talos/cmd/talosctl/pkg/mgmt/helpers\"\nARG ARTIFACTS\nRUN --mount=type=cache,target=/.cache/go-build GOOS=linux GOARCH=amd64 go test -c \\\n    -ldflags \"-s -w -X ${VERSION_PKG}.Name=Client -X ${VERSION_PKG}.SHA=${SHA} -X ${VERSION_PKG}.Tag=${TAG} -X ${MGMT_HELPERS_PKG}.ArtifactsPath=${ARTIFACTS}\" \\\n    -tags integration,integration_provision \\\n    ./internal/integration\n\nFROM scratch AS integration-test-provision-linux\nCOPY --from=integration-test-provision-linux-build /src/integration.test /integration-test-provision-linux-amd64\n\n# The lint target performs linting on the source code.\n\nFROM base AS lint-go\nCOPY .golangci.yml .\nENV GOGC=50\nRUN --mount=type=cache,target=/.cache/go-build golangci-lint run --config .golangci.yml\nRUN find . -name '*.pb.go' | xargs rm\nRUN FILES=\"$(gofumports -l -local github.com/talos-systems/talos .)\" && test -z \"${FILES}\" || (echo -e \"Source code is not formatted with 'gofumports -w -local github.com/talos-systems/talos .':\\n${FILES}\"; exit 1)\n\n# The protolint target performs linting on protobuf files.\n\nFROM base AS lint-protobuf\nWORKDIR /src/api\nCOPY api .\nCOPY prototool.yaml .\nRUN prototool lint --protoc-bin-path=/toolchain/bin/protoc --protoc-wkt-path=/toolchain/include\n\n# The markdownlint target performs linting on Markdown files.\n\nFROM node:8.16.1-alpine AS lint-markdown\nRUN npm i -g markdownlint-cli\nRUN npm i -g textlint\nRUN npm i -g textlint-rule-one-sentence-per-line\nWORKDIR /src\nCOPY .markdownlint.json .\nCOPY . .\nRUN markdownlint --ignore \"**/node_modules/**\" --ignore '**/hack/chglog/**' .\nRUN find . -name '*.md' -not -path '*/node_modules/*' -not -path '*/docs/talosctl/*' | xargs textlint --rule one-sentence-per-line --stdin-filename\n\n# The docs target generates documentation.\n\nFROM base AS docs-build\nRUN go generate ./pkg/config/types/v1alpha1\nCOPY --from=talosctl-linux /talosctl-linux-amd64 /bin/talosctl\nRUN mkdir -p /docs/talosctl \\\n    && env HOME=/home/user TAG=latest /bin/talosctl docs /docs/talosctl\n\nFROM scratch AS docs\nCOPY --from=docs-build /tmp/v1alpha1.md /docs/website/content/v0.4/en/configuration/v1alpha1.md\nCOPY --from=docs-build /docs/talosctl/* /docs/talosctl/",
    "raw_stdout_log": "Sending build context to Docker daemon  4.376MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 90: Unknown flag: mount",
    "html_url": "https://github.com/talos-systems/talos",
    "repo_commit": "688efabb93333a22807a1e3eaf5d0aac0ce0dd0d",
    "repo_id": 109451092
  },
  {
    "raw_dockerfile": "# syntax = docker/dockerfile:1.0-experimental\nFROM golang:1.14-alpine3.11 AS build\nWORKDIR /go/src/app\nRUN apk add --no-cache mailcap make tzdata\nENV TZ=GMT0\nRUN mv /usr/share/zoneinfo/${TZ} /etc/localtime\nCOPY . .\nRUN --mount=type=cache,target=~/.cache/go-build CGO_ENABLED=0 make build\n\nFROM alpine:3.11 AS app\nENV GOROOT=/go\nRUN apk add --no-cache ca-certificates\nCOPY --from=build /etc/mime.types /etc/localtime /etc/\nCOPY --from=build /usr/local/go/lib/time/zoneinfo.zip /go/lib/time/\nCOPY --from=build /go/src/app/bin /bin/\nCMD [\"app\"]",
    "raw_stdout_log": "Sending build context to Docker daemon  14.85kB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 8: Unknown flag: mount",
    "html_url": "https://github.com/orisano/gobase",
    "repo_commit": "39ac6d08cd589018e8f618d7ee9644603fa73dae",
    "repo_id": 117516525
  },
  {
    "raw_dockerfile": "# syntax=tonistiigi/dockerfile:runmount20181002\n\nFROM golang:1.11-alpine AS build\nWORKDIR /go/src/github.com/tonistiigi/buildkit-pack\nRUN apk add --no-cache file\nRUN --mount=target=. --mount=target=/root/.cache,type=cache \\\n  CGO_ENABLED=0 go build -o /out/pack ./cmd/pack && file /out/pack | grep \"statically linked\"\n  \nFROM scratch\nCOPY --from=build /out/pack /bin/pack\nENTRYPOINT [\"/bin/pack\"]",
    "raw_stdout_log": "Sending build context to Docker daemon  13.27MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 6: Unknown flag: mount",
    "html_url": "https://github.com/tonistiigi/buildkit-pack",
    "repo_commit": "80bf7e7e3afdc0572d276359ae0953df8da59d5b",
    "repo_id": 151502361
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\nARG openjdkversion=alpine\nFROM adoptopenjdk/maven-openjdk8-openj9 as builder\nLABEL maintainer=\"Pasquale Paola <pasquale.paola@gmail.com>\"\nWORKDIR /app\n#COPY settings.xml /root/.m2/\nCOPY ./ /app/\nRUN  --mount=type=cache,target=/root/.m2 mvn  -e -B package\n\nFROM adoptopenjdk/openjdk8-openj9:$openjdkversion as kiss-main-service\nLABEL maintainer=\"Pasquale Paola <pasquale.paola@gmail.com>\"\nCOPY --from=builder  /app/api/target/api-0.0.1-SNAPSHOT.jar /usr/kiss/\nWORKDIR /usr/kiss\nEXPOSE 8080\nCMD [\"java\", \"-XX:MaxRAM=4G\", \"-Djava.security.egd=file:/dev/./urandom\", \"-jar\", \"api-0.0.1-SNAPSHOT.jar\"]\n\nFROM httpd:2.4.39 as kiss-httpd\nLABEL maintainer=\"Pasquale Paola <pasquale.paola@gmail.com>\"\nEXPOSE 80\nCOPY httpd/proxy-html.conf /usr/local/apache2/conf/extra/\nCOPY httpd/httpd.conf /usr/local/apache2/conf/",
    "raw_stdout_log": "Sending build context to Docker daemon  369.7kB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 8: Unknown flag: mount",
    "html_url": "https://github.com/paspao/springboot-kiss-architecture",
    "repo_commit": "9fb4adf0ab89ce9d47a3ae630a9e9b0286e5c54a",
    "repo_id": 152395183
  },
  {
    "raw_dockerfile": "#syntax=docker/dockerfile:experimental\nFROM golang:1.12.3-alpine3.9 as build_base\nARG GOPROXY\nRUN apk add --no-cache --update alpine-sdk make git openssl gcc openssh\nRUN mkdir /src\nRUN mkdir /root/.ssh/\nRUN touch /root/.ssh/known_hosts\nRUN git config --global url.\"git@github.com:KompiTech\".insteadOf https://github.com/KompiTech\nRUN ssh-keyscan github.com >> /root/.ssh/known_hosts\nCOPY go.mod /src\nCOPY go.sum /src\nWORKDIR /src\nRUN --mount=type=ssh go mod download\n\nFROM build_base as build\nARG GOPROXY\nCOPY . /src\nWORKDIR /src\nRUN make build-linux\n\nFROM alpine:3.9\nRUN apk update && apk add ca-certificates && rm -rf /var/cache/apk/*\nWORKDIR /\nCOPY --from=build /src/build/_output/hl-fabric-operator.linux /\nENTRYPOINT [\"/hl-fabric-operator.linux\"]",
    "raw_stdout_log": "Sending build context to Docker daemon  1.018MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 13: Unknown flag: mount",
    "html_url": "https://github.com/KompiTech/hyperledger-fabric-operator",
    "repo_commit": "c2502bdcac9ff83aaca06e347e50717bb8d3c444",
    "repo_id": 157860617
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\n\n### Stage: Base image\nFROM node:10.14.2-alpine as base\nWORKDIR /app\nRUN mkdir -p dist node_modules .yarn-cache && chown -R node:node .\n\n\n### Stage: Development root with Chromium installed for unit tests\nFROM base as development\nENV \\\n  CHROME_BIN=/usr/bin/chromium-browser \\\n  LIGHTHOUSE_CHROMIUM_PATH=/usr/bin/chromium-browser \\\n  NODE_ENV=development\nRUN \\\n  echo \"http://dl-cdn.alpinelinux.org/alpine/edge/community\" >> /etc/apk/repositories \\\n  && echo \"http://dl-cdn.alpinelinux.org/alpine/edge/main\" >> /etc/apk/repositories \\\n  && echo \"http://dl-cdn.alpinelinux.org/alpine/edge/testing\" >> /etc/apk/repositories \\\n  && apk --no-cache update \\\n  && apk --no-cache upgrade \\\n  && apk add --no-cache git fontconfig bash udev ttf-opensans chromium rsync \\\n  && rm -rf /var/cache/apk/* /tmp/*\n# Install package dependancies for blip and mounted packages if present\nUSER node\nRUN mkdir -p /home/node/.yarn-cache /home/node/.cache/yarn\n# viz\nCOPY --chown=node:node packageMounts/@tidepool/viz/stub packageMounts/@tidepool/viz/yarn.lock* packageMounts/@tidepool/viz/package.json* packageMounts/@tidepool/viz/\nRUN --mount=type=cache,target=/home/node/.yarn-cache,id=yarn,uid=1000,gid=1000 cd packageMounts/@tidepool/viz && yarn install --cache-folder /home/node/.yarn-cache --silent --no-progress\n# blip\nCOPY --chown=node:node package.json yarn.lock ./\nRUN --mount=type=cache,target=/home/node/.yarn-cache,id=yarn,uid=1000,gid=1000 yarn install --cache-folder /home/node/.yarn-cache --silent --no-progress\n# tideline\nCOPY --chown=node:node packageMounts/tideline/stub packageMounts/tideline/yarn.lock* packageMounts/tideline/package.json* packageMounts/tideline/\nRUN --mount=type=cache,target=/home/node/.yarn-cache,id=yarn,uid=1000,gid=1000 cd packageMounts/tideline && yarn install --cache-folder /home/node/.yarn-cache --silent --no-progress\n# platform-client\nCOPY --chown=node:node packageMounts/tidepool-platform-client/stub packageMounts/tidepool-platform-client/yarn.lock* packageMounts/tidepool-platform-client/package.json* packageMounts/tidepool-platform-client/\nRUN --mount=type=cache,target=/home/node/.yarn-cache,id=yarn,uid=1000,gid=1000 cd packageMounts/tidepool-platform-client && yarn install --cache-folder /home/node/.yarn-cache --silent --no-progress\n# Copy the yarn cache mount to the standard yarn cache directory for quicker installs within running containers\nRUN --mount=type=cache,target=/home/node/.yarn-cache,id=yarn,uid=1000,gid=1000 (cd /home/node/.yarn-cache; tar cf - .) | (cd /home/node/.cache/yarn; tar xpf -)\n# Link any packages as needed\nARG LINKED_PKGS=\"\"\nRUN for i in ${LINKED_PKGS//,/ }; do cd packageMounts/${i} && yarn link && cd /app && yarn link ${i}; done\n# Copy source files\nCOPY --chown=node:node . .\nCMD [\"npm\", \"start\"]\n\n\n### Stage: Build production-ready release\nFROM base as build\n# ARGs\nARG API_HOST\nARG DISCOVERY_HOST=hakken:8000\nARG PORT=3000\nARG PUBLISH_HOST=hakken\nARG SERVICE_NAME=blip\nARG ROLLBAR_POST_SERVER_TOKEN\nARG TRAVIS_COMMIT\n# Set ENV from ARGs\nENV \\\n  API_HOST=$API_HOST \\\n  DISCOVERY_HOST=$DISCOVERY_HOST \\\n  PORT=$PORT \\\n  PUBLISH_HOST=$PUBLISH_HOST \\\n  SERVICE_NAME=$SERVICE_NAME \\\n  ROLLBAR_POST_SERVER_TOKEN=$ROLLBAR_POST_SERVER_TOKEN \\\n  TRAVIS_COMMIT=$TRAVIS_COMMIT \\\n  NODE_ENV=production\nUSER node\n# Copy all `node_modules` from `development` layer\nCOPY --from=development /app/node_modules ./node_modules\n# Copy source files, and possibily invalidate so we have to rebuild\nCOPY . .\nRUN npm run build\n\n\n### Stage: Serve production-ready release\nFROM base as production\nRUN apk --no-cache update \\\n  && apk --no-cache upgrade \\\n  && apk add --no-cache git\nCOPY package.json .\nCOPY yarn.lock .\n# Only install `node_modules` dependancies needed for production\nRUN yarn install --production --frozen-lockfile\nUSER node\n# Copy only files needed to run the server\nCOPY --from=build /app/dist dist\nCOPY --from=build \\\n  /app/config.server.js \\\n  /app/package.json \\\n  /app/server.js \\\n  ./\nCMD [\"npm\", \"run\", \"server\"]",
    "raw_stdout_log": "Sending build context to Docker daemon  5.718MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 28: Unknown flag: mount",
    "html_url": "https://github.com/tidepool-org/blip",
    "repo_commit": "45b1d97184a94542fddc8afdc25e8c34a6869cc9",
    "repo_id": 15945573
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\n\n# Copyright (c) 2019, NVIDIA CORPORATION. All rights reserved.\n#\n# Licensed under the Apache License, Version 2.0 (the \"License\");\n# you may not use this file except in compliance with the License.\n# You may obtain a copy of the License at\n#\n#     http://www.apache.org/licenses/LICENSE-2.0\n#\n# Unless required by applicable law or agreed to in writing, software\n# distributed under the License is distributed on an \"AS IS\" BASIS,\n# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n# See the License for the specific language governing permissions and\n# limitations under the License.\n\nARG BASE_IMAGE=nvcr.io/nvidia/pytorch:20.01-py3\n\n# build an image that includes only the nemo dependencies, ensures that dependencies\n# are included first for optimal caching, and useful for building a development\n# image (by specifying build target as `nemo-deps`)\nFROM ${BASE_IMAGE} as nemo-deps\n\n# Ensure apt-get won't prompt for selecting options\nENV DEBIAN_FRONTEND=noninteractive\nRUN apt-get update && \\\n    apt-get install -y \\\n    libsndfile1 sox \\\n    python-setuptools \\\n    python-dev && \\\n    rm -rf /var/lib/apt/lists/*\n\n# install trt\nENV PATH=$PATH:/usr/src/tensorrt/bin\nWORKDIR /tmp/trt-oss\nARG NV_REPO=https://developer.download.nvidia.com/compute/machine-learning/repos/ubuntu1804/x86_64\n\nRUN cd /tmp/trt-oss\nARG DEB=libcudnn7_7.6.5.32-1+cuda10.2_amd64.deb\nRUN curl -sL --output ${DEB} ${NV_REPO}/${DEB}\nARG DEB=libnvinfer7_7.0.0-1+cuda10.2_amd64.deb\nRUN curl -sL --output ${DEB} ${NV_REPO}/${DEB}\nARG DEB=libnvinfer-plugin7_7.0.0-1+cuda10.2_amd64.deb\nRUN curl -sL --output ${DEB} ${NV_REPO}/${DEB}\nARG DEB=libnvonnxparsers7_7.0.0-1+cuda10.2_amd64.deb\nRUN curl -sL --output ${DEB} ${NV_REPO}/${DEB}\nARG DEB=python-libnvinfer_7.0.0-1+cuda10.2_amd64.deb\nRUN curl -sL --output ${DEB} ${NV_REPO}/${DEB}\nRUN dpkg -i *.deb && cd ../.. && rm -rf /tmp/trt-oss\n\n# install nemo dependencies\nWORKDIR /tmp/nemo\nCOPY requirements/requirements_docker.txt requirements.txt\nRUN pip install --disable-pip-version-check --no-cache-dir -r requirements.txt\n\n# copy nemo source into a scratch image\nFROM scratch as nemo-src\nCOPY . .\n\n# start building the final container\nFROM nemo-deps as nemo\nARG NEMO_VERSION\nARG BASE_IMAGE\n\n# Check that NEMO_VERSION is set. Build will fail without this. Expose NEMO and base container\n# version information as runtime environment variable for introspection purposes\nRUN /usr/bin/test -n \"$NEMO_VERSION\" && \\\n    /bin/echo \"export NEMO_VERSION=${NEMO_VERSION}\" >> /root/.bashrc && \\\n    /bin/echo \"export BASE_IMAGE=${BASE_IMAGE}\" >> /root/.bashrc\nRUN --mount=from=nemo-src,target=/tmp/nemo cd /tmp/nemo && pip install \".[all]\"\n\n# copy scripts/examples/tests into container for end user\nWORKDIR /workspace/nemo\nCOPY scripts /workspace/nemo/scripts\nCOPY examples /workspace/nemo/examples\nCOPY tests /workspace/nemo/tests\nCOPY README.rst LICENSE /workspace/nemo/\n\nRUN printf \"#!/bin/bash\\njupyter lab --no-browser --allow-root --ip=0.0.0.0\" >> start-jupyter.sh && \\\n    chmod +x start-jupyter.sh",
    "raw_stdout_log": "Sending build context to Docker daemon   15.9MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 70: Unknown flag: mount",
    "html_url": "https://github.com/NVIDIA/NeMo",
    "repo_commit": "b2712fd98226e5ab6d2be0b873e47759166f1f24",
    "repo_id": 200722670
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\nFROM thinhda/spring-grpc-base as base\n\nWORKDIR /app\nADD core /app\nRUN --mount=type=cache,id=cache-maven,target=/root/.m2 mvn clean install\n\nFROM openjdk:11.0.2-slim\nWORKDIR /app\n\nEXPOSE 6790\nEXPOSE 6789\n\nCOPY --from=base /app/target/*.jar .\nCMD java -jar app.jar",
    "raw_stdout_log": "Sending build context to Docker daemon  278.5kB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 6: Unknown flag: mount",
    "html_url": "https://github.com/thinhdanggroup/spring_grpc_http",
    "repo_commit": "f9ff58f3674e313c074ddae205c534313fc29fc0",
    "repo_id": 202969231
  },
  {
    "raw_dockerfile": "# syntax = docker/dockerfile:experimental\n\nFROM concourse/golang-builder AS builder\n  WORKDIR /src\n  COPY go.mod /src/go.mod\n  COPY go.sum /src/go.sum\n  RUN --mount=type=cache,target=/root/.cache/go-build go get -d ./...\n  COPY . /src\n  ENV CGO_ENABLED 0\n  RUN go build -o /assets/task ./cmd/task\n  RUN go build -o /assets/build ./cmd/build\n\nFROM moby/buildkit:v0.7.0 AS task\n  COPY --from=builder /assets/task /usr/bin/\n  COPY --from=builder /assets/build /usr/bin/\n  COPY bin/setup-cgroups /usr/bin/\n  ENTRYPOINT [\"task\"]\n\nFROM task",
    "raw_stdout_log": "Sending build context to Docker daemon  240.6kB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 7: Unknown flag: mount",
    "html_url": "https://github.com/vito/oci-build-task",
    "repo_commit": "230df3baa27fb389484ee0fb74355cd8b7977298",
    "repo_id": 204168458
  },
  {
    "raw_dockerfile": "# syntax = docker/dockerfile-upstream:1.1.4-experimental\n\nFROM golang:1.13 AS build\nENV GO111MODULE on\nENV GOPROXY https://proxy.golang.org\nENV CGO_ENABLED 0\nWORKDIR /tmp\nRUN go get sigs.k8s.io/controller-tools/cmd/controller-gen@v0.2.8\nRUN go get k8s.io/code-generator/cmd/conversion-gen@v0.18.2\nWORKDIR /src\nCOPY ./go.mod ./\nCOPY ./go.sum ./\nRUN go mod download\nRUN go mod verify\nCOPY ./ ./\nRUN go list -mod=readonly all >/dev/null\nRUN ! go mod tidy -v 2>&1 | grep .\n\nFROM build AS manifests-build\nARG NAME\nRUN controller-gen crd:crdVersions=v1 paths=\"./api/...\" output:crd:dir=config/crd/bases output:webhook:dir=config/webhook webhook\nRUN controller-gen rbac:roleName=manager-role paths=\"./controllers/...\" output:rbac:dir=config/rbac\nFROM scratch AS manifests\nCOPY --from=manifests-build /src/config /config\n\nFROM build AS generate-build\nRUN controller-gen object:headerFile=./hack/boilerplate.go.txt paths=\"./...\"\nRUN\tconversion-gen --input-dirs=./api/v1alpha2 --output-base ./ --output-file-base=zz_generated.conversion --go-header-file=./hack/boilerplate.go.txt\nFROM scratch AS generate\nCOPY --from=generate-build /src/api /api\n\nFROM k8s.gcr.io/hyperkube:v1.17.0 AS release-build\nRUN apt update -y \\\n  && apt install -y curl \\\n  && curl -LO https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv3.4.0/kustomize_v3.4.0_linux_amd64.tar.gz \\\n  && tar -xf kustomize_v3.4.0_linux_amd64.tar.gz -C /usr/local/bin \\\n  && rm kustomize_v3.4.0_linux_amd64.tar.gz\nCOPY ./config ./config\nARG REGISTRY_AND_USERNAME\nARG NAME\nARG TAG\nRUN cd config/manager \\\n  && kustomize edit set image controller=${REGISTRY_AND_USERNAME}/${NAME}:${TAG} \\\n  && cd - \\\n  && kustomize build config > /bootstrap-components.yaml \\\n  && cp config/metadata/metadata.yaml /metadata.yaml\nFROM scratch AS release\nCOPY --from=release-build /bootstrap-components.yaml /bootstrap-components.yaml\nCOPY --from=release-build /metadata.yaml /metadata.yaml\n\nFROM build AS binary\nRUN --mount=type=cache,target=/root/.cache/go-build GOOS=linux go build -ldflags \"-s -w\" -o /manager\nRUN chmod +x /manager\n\nFROM scratch AS container\nCOPY --from=docker.io/autonomy/ca-certificates:v0.1.0 / /\nCOPY --from=docker.io/autonomy/fhs:v0.1.0 / /\nCOPY --from=binary /manager /manager\nENTRYPOINT [ \"/manager\" ]",
    "raw_stdout_log": "Sending build context to Docker daemon  505.9kB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 52: Unknown flag: mount",
    "html_url": "https://github.com/talos-systems/cluster-api-bootstrap-provider-talos",
    "repo_commit": "7ed11c79b6384c95e14b272415b39a0ee1ac69da",
    "repo_id": 214525348
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\n\nFROM golang:1.13-alpine as builder\n\nENV CGO_ENABLED 0\nENV GOOS linux\nENV GOARCH amd64\n\nRUN apk update && apk upgrade\n\nWORKDIR /build/\n\nCOPY go.mod go.sum /build/\nRUN --mount=type=cache,target=/root/go/pkg/mod go mod download\n\nCOPY main.go /build/main.go\nCOPY api /build/api\nCOPY controllers /build/controllers\n\nRUN --mount=type=cache,target=/root/.cache/go-build go build -trimpath -o /usr/local/bin/main -ldflags=\"-s -w\" /build/main.go\n\nFROM gcr.io/distroless/static:nonroot\nCOPY --from=builder /usr/local/bin/main /usr/local/bin/main\nUSER nonroot:nonroot\n\nENTRYPOINT [\"/usr/local/bin/main\"]",
    "raw_stdout_log": "Sending build context to Docker daemon  264.7kB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 14: Unknown flag: mount",
    "html_url": "https://github.com/kaidotdev/vegeta-controller",
    "repo_commit": "96af664760033c162f72cf32604a3829aae3f31b",
    "repo_id": 216686448
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\n\n\n# Build stage: Install python dependencies\n# ===\nFROM ubuntu:focal AS python-dependencies\nRUN apt-get update && apt-get install --no-install-recommends --yes python3-pip python3-setuptools\nADD requirements.txt /tmp/requirements.txt\nRUN --mount=type=cache,target=/root/.cache/pip pip3 install --user --requirement /tmp/requirements.txt\n\n\n# Build stage: Install yarn dependencies\n# ===\nFROM node:12-slim AS yarn-dependencies\nWORKDIR /srv\nADD package.json package.json\nRUN --mount=type=cache,target=/usr/local/share/.cache/yarn yarn install\n\n\n# Build stage: Build vanilla-framework itself\n# ===\nFROM yarn-dependencies AS build-vanilla\nADD scss scss\nADD sass-functions.js sass-functions.js\nRUN yarn run build\n\n\n# Build the production image\n# ===\nFROM ubuntu:focal\n\n# Set up environment\nENV LANG C.UTF-8\nWORKDIR /srv\n\n# Install python and import python dependencies\nRUN apt-get update && apt-get install --no-install-recommends --yes python3-lib2to3 python3-pkg-resources\nCOPY --from=python-dependencies /root/.local/lib/python3.8/site-packages /root/.local/lib/python3.8/site-packages\nCOPY --from=python-dependencies /root/.local/bin /root/.local/bin\nENV PATH=\"/root/.local/bin:${PATH}\"\n\n# Import code, build assets and mirror list\nADD . .\nRUN rm -rf package.json yarn.lock .babelrc webpack.config.js\nCOPY --from=build-vanilla /srv/package.json package.json\nCOPY --from=build-vanilla /srv/build build\n\n# Set revision ID\nARG BUILD_ID\nENV TALISKER_REVISION_ID \"${BUILD_ID}\"\n\n# Setup commands to run server\nENTRYPOINT [\"./entrypoint\"]\nCMD [\"0.0.0.0:80\"]",
    "raw_stdout_log": "Sending build context to Docker daemon  7.407MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 9: Unknown flag: mount",
    "html_url": "https://github.com/canonical-web-and-design/vanilla-framework",
    "repo_commit": "22b244cee24525f48aa77303bfbe7ce655e0305a",
    "repo_id": 31207344
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\n\n# Using Ubuntu 19.10 for now\nFROM ubuntu:eoan AS builder\nLABEL description=\"Development build environment\"\n\n# Update the distro and install our tools\nRUN apt-get -y update && apt-get install -y \\\n && apt-get -y install clang \\\n && apt-get -y install cmake \\\n && apt-get -y install git \\\n# dragging libstdc++-9 in for std::filesystem\n && apt-get -y install libstdc++-9-dev \\\n && apt-get -y install software-properties-common \\\n && add-apt-repository -y ppa:team-xbmc/ppa \\\n# Install required library packages\n && apt-get install -y libbotan-2-dev \\\n && apt-get install -y libboost-program-options1.67-dev \\\n && apt-get install -y libboost-locale1.67-dev \\\n && apt-get install -y libboost-system1.67-dev \\\n && apt-get install -y libmysqlcppconn-dev \\\n && apt-get install -y zlib1g-dev \\\n && apt-get install -y libpcre3-dev \\\n# Pulled from XBMC PPA\n && apt-get install -y flatbuffers-dev\n\n# Copy source\nARG working_dir=/usr/src/ember\nCOPY . ${working_dir}\nWORKDIR ${working_dir}\nRUN update-alternatives --install /usr/bin/cc cc /usr/bin/clang 100 \\\n    && update-alternatives --install /usr/bin/c++ c++ /usr/bin/clang++ 100\n# CMake arguments\n# These can be overriden by passing them through to `docker build`\nARG build_optional_tools=1\nARG pcre_static_lib=1\nARG disable_threads=0\nARG build_type=Rel\nARG install_dir=/usr/local/bin\n\n# Generate Makefile & compile\nRUN --mount=type=cache,target=build \\\n    cmake -S . -B build \\\n    -DCMAKE_BUILD_TYPE=${build_type} \\\n    -DCMAKE_INSTALL_PREFIX=${install_dir} \\\n    -DBUILD_OPT_TOOLS=${build_optional_tools} \\\n    -DPCRE_STATIC_LIB=${pcre_static_lib} \\\n    -DDISABLE_EMBER_THREADS=${disable_threads} \\\n    -DBOTAN_ROOT_DIR=/usr/include/botan-2/ \\\n    -DBOTAN_LIBRARY=/usr/lib/x86_64-linux-gnu/libbotan-2.so \\\n    && cd build && make -j install && make test\n\nFROM ubuntu:eoan AS run_environment\nARG install_dir=/usr/local/bin\nARG working_dir=/usr/src/ember\nWORKDIR ${install_dir}\nRUN apt-get -y update \\\n    && apt-get install -y libbotan-2-9 \\\n    && apt-get install -y libmysqlcppconn7v5 \\\n    && apt-get install -y mysql-client\nCOPY --from=builder ${install_dir} ${install_dir}\nRUN cp configs/*.dist .\nCOPY ./sql ${install_dir}/sql\nCOPY ./scripts ${install_dir}\nCOPY ./dbcs ${install_dir}/dbcs",
    "raw_stdout_log": "Sending build context to Docker daemon  5.155MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 42: Unknown flag: mount",
    "html_url": "https://github.com/EmberEmu/Ember",
    "repo_commit": "bcf4bbdcaf5c8751d159c0bc3eb63a86161561aa",
    "repo_id": 37888564
  },
  {
    "raw_dockerfile": "# syntax=docker/dockerfile:experimental\nFROM node:13-alpine AS assets\nRUN apk add --update sassc\nWORKDIR /weasyl-build\nRUN chown node:node /weasyl-build\nUSER node\nCOPY package.json package-lock.json ./\nRUN npm install --ignore-scripts\nCOPY build.js build.js\nCOPY assets assets\nRUN node build.js\n\n\nFROM python:2.7-alpine3.11 AS bdist-lxml\n# libxml2-dev, libxslt-dev: lxml\nRUN apk add --update \\\n    musl-dev gcc make \\\n    libxml2-dev libxslt-dev\nRUN adduser -S build -h /weasyl-build -u 100\nWORKDIR /weasyl-build\nUSER build\nRUN --mount=type=cache,id=pip,target=/weasyl-build/.cache/pip,sharing=private,uid=100 pip2 wheel -w dist lxml==4.5.0\n\n\nFROM python:2.7-alpine3.11 AS bdist\n# imagemagick6-dev: sanpera\n# libjpeg-turbo-dev, libwebp-dev, zlib-dev: Pillow\n# libffi-dev, openssl-dev: cryptography\n# libmemcached-dev: pylibmc\n# postgresql-dev: psycopg2cffi\n# xz-dev: backports.lzma\nRUN apk add --update \\\n    musl-dev gcc make \\\n    imagemagick6-dev \\\n    libffi-dev \\\n    libjpeg-turbo-dev \\\n    libmemcached-dev \\\n    libwebp-dev \\\n    openssl-dev \\\n    postgresql-dev \\\n    xz-dev \\\n    zlib-dev\nRUN adduser -S build -h /weasyl-build -u 100\nWORKDIR /weasyl-build\nUSER build\nCOPY etc/requirements.txt requirements.txt\nRUN --mount=type=cache,id=pip,target=/weasyl-build/.cache/pip,sharing=private,uid=100 pip2 wheel -w dist -r requirements.txt\nCOPY --chown=build:nobody libweasyl libweasyl\nRUN cd libweasyl && python2 setup.py bdist_wheel -d ../dist2\nCOPY setup.py setup.py\nCOPY weasyl weasyl\nRUN python2 setup.py bdist_wheel -d dist2\n\n\nFROM python:2.7-alpine3.11 AS bdist-pytest\nRUN adduser -S build -h /weasyl-build -u 100\nWORKDIR /weasyl-build\nUSER build\nRUN --mount=type=cache,id=pip,target=/weasyl-build/.cache/pip,sharing=private,uid=100 pip2 wheel -w dist pytest==4.6.5\n\n\nFROM python:2.7-alpine3.11 AS package\nRUN apk add --update \\\n    py3-virtualenv \\\n    imagemagick6-libs \\\n    libffi \\\n    libjpeg-turbo \\\n    libmemcached-libs \\\n    libwebp \\\n    libxslt \\\n    postgresql-dev\nRUN adduser -S weasyl -h /weasyl\nWORKDIR /weasyl\nUSER weasyl\nRUN virtualenv -p python2 .venv\nCOPY etc/requirements.txt etc/requirements.txt\n\nRUN --mount=type=bind,target=install-wheels,source=/weasyl-build/dist,from=bdist-lxml .venv/bin/pip install --no-deps install-wheels/*\nRUN --mount=type=bind,target=install-wheels,source=/weasyl-build/dist,from=bdist .venv/bin/pip install --no-deps install-wheels/*\n\nRUN --mount=type=bind,target=install-wheels,source=/weasyl-build/dist2,from=bdist [\".venv/bin/pip\", \"install\", \"--no-deps\", \\\n    \"install-wheels/libweasyl-0.0.0-py2-none-any.whl\", \\\n    \"install-wheels/weasyl-0.0.0-py2-none-any.whl\"]\n\nCOPY --from=assets /weasyl-build/build build\n\nCOPY weasyl/weasyl.tac ./\n\nARG version\nRUN test -n \"$version\" && printf '%s\\n' \"$version\" > version.txt\n\nFROM package AS test\nRUN --mount=type=bind,target=install-wheels,source=/weasyl-build/dist,from=bdist-pytest .venv/bin/pip install --no-deps install-wheels/*\nENV WEASYL_APP_ROOT=.\nENV WEASYL_STORAGE_ROOT=testing/storage\nENV PATH=\"/weasyl/.venv/bin:${PATH}\"\nCOPY pytest.ini ./\nCOPY assets assets\nCMD pytest -x libweasyl.test libweasyl.models.test && pytest -x weasyl.test\n\nFROM package\nENV WEASYL_APP_ROOT=/weasyl\nENV WEASYL_WEB_ENDPOINT=tcp:8080\nCMD [\".venv/bin/twistd\", \"--nodaemon\", \"--python=weasyl.tac\", \"--pidfile=/tmp/twistd.pid\"]\nEXPOSE 8080\nSTOPSIGNAL SIGINT",
    "raw_stdout_log": "Sending build context to Docker daemon  4.148MB",
    "raw_stderr_log": "Error response from daemon: Dockerfile parse error line 22: Unknown flag: mount",
    "html_url": "https://github.com/Weasyl/weasyl",
    "repo_commit": "f4efde7ce02be68f9eb8b0502fe3900262eaa1ef",
    "repo_id": 58244355
  }
]